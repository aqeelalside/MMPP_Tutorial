{"name":"MMPP Tutorial","tagline":"A review of Markov Modulated Poisson Processes (MMPPs) and a simple tutorial for the MMPP R module","body":"The following tutorial is based on three papers:\r\n\r\n* [Learning to Detect Events with Markov-Modulated Poisson Processes](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.87.3348) by A. Ihler, J. Hutchins, and P. Smyth\r\n* [Detecting Network Intrusion Using a Markov Modulated Nonhomogeneous Poisson Process](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.8659) by S. Scott\r\n* [The Markov Modulated Poisson Process and Markov Poisson Cascade with Applications to Web Traffic Modeling](http://www.datalab.uci.edu/papers/ScottSmythV7.pdf) by S. Scott and P. Smyth.\r\n\r\nThis R-implementation is based on the Matlab code provided by J.Hutchins.\r\n\r\nThe dataset used for this tutorial is available on the UCI Machine Learning Repository [here.](http://archive.ics.uci.edu/ml/datasets/CalIt2+Building+People+Counts)\r\n\r\n# When and why should I use a Markov-Modulated Poisson Process?\r\nTime-series of count data occur in many different contexts.  A Markov-modulated Poisson process provides a framework for detecting anomalous events using an unsupervised learning approach and has several advantages compared to typical Poisson models.\r\n\r\nThe following figure shows three weeks of entry count data recorded every 30 minutes by an optical sensor placed at the main doors of the [Calit2 Institute building](http://www.calit2.uci.edu/calit2-building/default.aspx?cguid=7CE08025-DA82-4BF8-A57B-2F16D8C7592C) on the UC-Irvine campus. These observations are noisy time series with obvious structure which are corrupted by non-periodic events.  Some events, such as the large spike on the second Thursday in the plot below, may be obvious; others may only be noticeable when compared to the average behavior at given time over a long period.\r\n\r\n![Plot of Entry Data](assets/img/exit_count.png)\r\n\r\nIf your data is close to Poisson, the Markov-modulated Poisson process has several advantages over estimating a non-homogenous poisson process and detecting events by finding counts with low probability under the estimated model, $$P(N;\\hat{\\lambda}(t)) < \\epsilon$$\r\n\r\n1. The presence of outliers causes bias in the estimated rate of average behavior.\r\n2. Sustained events with slight changes may not be detected with a constant probability threshold.\r\n3. Difficulty in determining the duration of events.\r\n\r\nIf you believe your data contains events which are relatively rare and interspersed among non-event observations and any event causes a dramatic change in activity, a simple non-homogeneous poisson process model will likely suffice.  Otherwise, the MMPP will likely perform significantly better in terms of detection accuracy.\r\n\r\n# Poisson processes\r\nIf your data follows a Poisson process, the probability of observing $$N$$ events at any time is given by the following:  \r\n\r\n$$P(N;\\lambda)=e^{-\\lambda}\\lambda^N/N!$$\r\n\r\nThe population mean and variance are both equal to $$\\lambda$$.  There are several goodness of fit tests available to test the Poisson distribution assumption.  However, given that the data may be contaminated by bursts of events and the fact that limited observations at each day-time slice may be a problem, a qualitative assessment of the suitability of the Poisson assumption is reasonable and can be obtained by examining the relationship between the mean and variance of observations.\r\n\r\n![Plot of chunk unnamed-chunk-1](assets/fig/unnamed-chunk-3.png)\r\n\r\nThe mean and variance plots indicate that after the removal of observations affected by events, the Poisson assumption seems reasonable.\r\n\r\nAs motivation for the proposed model, consider the scatterplot of the number of individuals entering the building on any weekday as function of every 30-minute interval.  There is obvious periodic behavior as well as several patches of outliers.  However, in some cases it is not so obvious as to whether observations are due to an external event or just unusual noise.  In order to separate the these scenarios, Ihler et al. defined the model described in the next section.\r\n\r\n![Plot of chunk unnamed-chunk-2](assets/fig/img2.png)\r\n\r\n# Markov-Modulated Poisson Process\r\nThe main assumption underlying the Markov-Modulated Poisson Process is that observed count at time t,  $$N(t)$$, is the sum of a baseline Poisson process $$N_0(t)$$ which corresponds to normal activity and a Poisson process corresponding $$N_E(t)$$ to external events.  That is,\r\n\r\n$$N(t) = N_0(t) + N_E(t)$$\r\n\r\nIn order to model the predictable and periodic behavior seen in the above figure, the proposed model for $$N_0(t)$$ is a non-homogenous Poisson process with a particular parametrization of the rate function.\r\n\r\n$$\\lambda(t) = \\lambda_0 \\delta_{d(t)} \\eta_{d(t),h(t)}$$\r\n\r\n$$d(t) \\in [1,2,3,4,5,6,7]$$ and $$h(t)$$ indicates the time interval $$t$$, such as every 30 minutes, etc.  The parameters $$\\delta$$ and $$\\eta$$ must meet the following criteria:\r\n\r\n$$\\begin{align}\r\n\\sum_{i=1}^N \\delta_i &= 7\\\\\r\n\\sum_{j=1}^D \\eta_{i,j} &= D\\\\\r\n\\end{align}$$\r\n\r\n\r\n\r\nWhere D is the number of time intervals in one day (e.g. 24 for one hour intervals, 48 for 30 minute intervals)\r\n\r\n# Modeling Rare, Persistent Events\r\nTo model the behavior of anomalous periods of time, we use a ternary process $$z(t)$$ to indicate the presence of an event and its type:\r\n\r\n$$z(t) =\r\n     \\begin{array}{lr}\r\n        0 & \\textrm{no event at time t}\\\\\r\n       +1 & \\textrm{positive event at time t}\\\\\r\n       -1 & \\textrm{negative event at time t}\\\\\r\n     \\end{array}$$\r\n\r\n$$M_z =\r\n    \\left( \\begin{array}{ccc}\r\n        z_{00} & z_{0+} & z_{0-}\\\\\r\n        z_{+0} & z_{++} & z_{+-}\\\\\r\n        z_{-0} & z_{-+} & z_{--}\\\\\r\n    \\end{array} \\right)$$\r\n\r\n\r\nThe transition probability variables priors are specified as\r\n\r\n$$z_{00},z_{0+},z_{0-} \\sim \\textrm{Dir}(z; [a_{00}^Z,a_{0+}^Z,a_{0-}^Z])$$\r\n\r\nwhere Dir is the Dirichlet distribution and the $$a_{0\\cdot}^Z$$ are hyperparameters.  Given an event $$z(t)\\neq 1$$, the increase or decrease in observation counts, $$N_E(t)$$, is modeled as Poisson with rate $$\\gamma (t)$$ where  $$\\gamma (t)$$ is assumed to be independently distributed as the Gamma distribution with hyperparameters $$a^E$$ and $$b^E$$.\r\n\r\n$$\\gamma (t) \\sim \\Gamma(\\gamma;a^E,b^E)$$\r\n\r\nMarkov modulated Poisson processes may be relatively sensitive to the selection of prior distributions and hence the choice of hyper-parameters.  However, given an idea of what constitutes a “rare” event, how often they occur, and the expected duration of such an event relatively strong priors can avoid over-explanation of the data.\r\n\r\n# Estimation of the model\r\nThe model is estimated via MCMC by iterating between drawing samples of the hidden variables and sampling the parameters given the complete data.\r\n\r\nSampling the hidden variables given the parameters:\r\n\r\nGiven $$\\lambda (t)$$ and $$M_z$$, the event process $$z(t)$$ can be sampled using a variant of the Forward-Backward algorithm.  Given $$z(t)$$, $$N_0(t)$$ and $$N_e(t)$$ are determined through sampling their posterior distributions.\r\n\r\nSampling the parameters given the complete data:  \r\n\r\nLeaving out details, the complete likelihood function for the model given by:\r\n\r\n$$\\displaystyle \\prod_t e^{\\lambda(t)}\\lambda(t)^{N_0(t)} \\prod_t p(Z(t)|Z(t-1)) \\prod_{Z(t)=1}NBin(N_E(t))$$\r\n\r\nConsider the first term of the likelihood function and by choosing conjugate prior distributions, the posterior distributions of $$\\lambda_0$$, $$\\delta$$, and $$\\eta$$ are the same form with parameters given by sufficient statistics of the data.  The posterior distributions are as follows:\r\n\r\n$$\\begin{align}\r\n\\lambda_0 &\\sim \\Gamma(\\lambda ; a^L + S, b^L +T)\\\\\r\n\\frac{1}{7}[\\delta_1, \\dots, \\delta_7] &\\sim Dir(\\alpha_1^d+S_1, \\dots,\\alpha_7^d+S_7 )\\\\\r\n\\frac{1}{D}[\\eta_{j,1}, \\dots, \\eta_{j,D}] &\\sim Dir(\\alpha_1^h+S_{j,1}, \\dots,\\alpha_D^h+S_{j,D} )\\\\\r\n\\end{align}$$\r\n\r\nwhere\r\n\r\n$$\\begin{align}\r\nS_{i,j} &= \\sum_{d(t)=j,h(t)=i} N_0(t)\\\\\r\nS_k &= \\sum_i S_{j,i}\\\\\r\nS &= \\sum_j S_j\\\\\r\nT &= 7DW\\\\\r\n\\end{align}$$\r\n\r\nIn a similar fashion, the posterior distribution for the transition probabilities are obtained:\r\n\r\n$$[z_{00},z_{0+},z_{0-}] \\sim Dir(z; a_{00}^Z+Z_{00},a_{0+}^Z+Z_{0=},a_{0-}^Z+Z_{0-})$$\r\n\r\nwhere $$Z_{0+}$$ is the total number of transitions where $$z(t)=0, z(t+1)=+1$$.\r\n\r\n# Data format\r\nIn order to use the MMPP estimator, your data should be formatted as an R matrix where each column corresponds to one day’s worth of data.  Each row corresponds to one period during the day.\r\n\r\nIf your data is a delimited text file with a `timestamp` column and an  `event-count` column, you can import it into an R data frame using `read.csv`.  Assuming the name of the resulting data frame is `data` and the columns are named `date` and `count`, the following command will create the matrix:\r\n\r\n~~~ r\r\nN<-matrix(data$count, nrow = D, ncol = N)\r\n~~~\r\n\r\nHere, `D` is the number of intervals per 24 hours and `N` is the total number of days in your dataset.\r\n\r\n## Running The Code\r\n\r\n### Inputs\r\nThe inputs parameters are as follows:\r\n\r\n#### `N`: The count data matrix\r\nExample of seven days worth count data (counts indicate number of building entries per 30 minute interval)\r\n\r\n~~~\r\n##       [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n##  [1,]    0    1    0    1    0    4    0\r\n##  [2,]    1    0    4    2    0    1    2\r\n##  [3,]    0    0    0    0    2    0    0\r\n##  [4,]    0    0    2    0    0    1    2\r\n##  [5,]    0    0    0    0    0    0    0\r\n##  [6,]    2    0    0    0    0    0    1\r\n##  [7,]    0    0    0    0    0    2    0\r\n##  [8,]    0    0    0    1    0    0    0\r\n##  [9,]    0    0    0    0    0    0    0\r\n## [10,]    0    0    0    0    2    0    0\r\n## [11,]    0    2    0    0    0    0    0\r\n## [12,]    0    2    3    0    0    0    0\r\n## [13,]    0    1    0    1    0    3    0\r\n## [14,]    0    1    1    0    0    0    0\r\n## [15,]    0    0    0    0    1    0    0\r\n## [16,]    2    0    0    0    0    0    0\r\n## [17,]    0    0    2    0    3    0    0\r\n## [18,]    0    2    6    0    2    3    0\r\n## [19,]    0    1    2    2    0    1    0\r\n## [20,]    1    5    2    1   11   15    0\r\n## [21,]    0    4    4    6    3   26    0\r\n## [22,]    0    9   18    7    7   13    0\r\n## [23,]    1    1    8   11    7    9    0\r\n## [24,]    0    7    9   14   14    6    0\r\n## [25,]    0   11    8   14   28   23    0\r\n## [26,]    0    4    6    6   21   12    0\r\n## [27,]    0    7   25   33   10   11    0\r\n## [28,]    0    3   12   24   19    3    1\r\n## [29,]    0   14   13    4   11    7    1\r\n## [30,]    0    7   12    6   12    4    0\r\n## [31,]    0   10   11   17    9    9    0\r\n## [32,]    0    6    4   15   14    5    2\r\n## [33,]    0   13    8    9    9    8    1\r\n## [34,]    0    8    4    7   10   20    0\r\n## [35,]    1    9   17   16    8    6    2\r\n## [36,]    2    3   10   13   14    3    1\r\n## [37,]    4    6    8    7   15    6    0\r\n## [38,]    1    5    6    2    4    4    0\r\n## [39,]    2    2    7    1    2    1    0\r\n## [40,]    1    5    1    1    0    0    1\r\n## [41,]    0    1    2    3    2    0    0\r\n## [42,]    0    3    0    2    0    1    0\r\n## [43,]    3    0    2    0    0    2    0\r\n## [44,]    2    0    0    1    0    1    0\r\n## [45,]    0    1    2    0    1    1    0\r\n## [46,]    0    2    0    0    0    5    1\r\n## [47,]    2    3    1    1    3    1    0\r\n## [48,]    0    3    0    2    0    3    0\r\n~~~\r\n\r\n#### `priors`: A list containing each of the specified prior hyperparameters\r\n~~~ r\r\npriors<-list()\r\npriors$aL=1\r\npriors$bL=1 #lambda0, baseline rate\r\npriors$aD=rep(0,1,7)+5 #day effect dirichlet params\r\npriors$aH=matrix(0,nrow=48,ncol=7)+1 #time of day effect dirichlet param\r\npriors$z01=.01*10000\r\npriors$z00=.99*10000   #z(t) event process\r\n\r\npriors$z01 = .01*10000; priors$z00 = .99*10000;     # z(t) event process\r\npriors$z10 = .25*10000; priors$z11 = .75*10000;     \r\npriors$aE = 5; priors$bE = 1/3;       # gamma(t), or NBin, for event # process\r\n\r\npriors$MODE = 0;\r\n~~~\r\n\r\n#### `ITER`: A list containing the number of iterations and the length of the burn-in period\r\n\r\n~~~ r\r\nITER <- c(50, 10)\r\n~~~\r\n\r\n#### `events`: Matrix containing the locations of known events (used for verification)\r\n~~~\r\n##       [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n##  [1,]    0    0    0    0    0    0    0\r\n##  [2,]    0    0    0    0    0    0    0\r\n##  [3,]    0    0    0    0    0    0    0\r\n##  [4,]    0    0    0    0    0    0    0\r\n##  [5,]    0    0    0    0    0    0    0\r\n##  [6,]    0    0    0    0    0    0    0\r\n##  [7,]    0    0    0    0    0    0    0\r\n##  [8,]    0    0    0    0    0    0    0\r\n##  [9,]    0    0    0    0    0    0    0\r\n## [10,]    0    0    0    0    0    0    0\r\n## [11,]    0    0    0    0    0    0    0\r\n## [12,]    0    0    0    0    0    0    0\r\n## [13,]    0    0    0    0    0    0    0\r\n## [14,]    0    0    0    0    0    0    0\r\n## [15,]    0    0    0    0    0    0    0\r\n## [16,]    0    0    0    0    0    1    0\r\n## [17,]    0    0    0    0    0    1    0\r\n## [18,]    0    0    0    0    0    1    0\r\n## [19,]    0    0    0    0    0    1    0\r\n## [20,]    0    0    0    0    0    1    0\r\n## [21,]    0    0    0    0    0    1    0\r\n## [22,]    0    0    1    0    0    1    0\r\n## [23,]    0    0    1    0    0    0    0\r\n## [24,]    0    0    1    0    0    0    0\r\n## [25,]    0    0    1    0    0    0    0\r\n## [26,]    0    0    1    0    0    0    0\r\n## [27,]    0    0    1    0    0    0    0\r\n## [28,]    0    0    1    0    0    0    0\r\n## [29,]    0    0    0    0    0    0    0\r\n## [30,]    0    0    0    0    0    0    0\r\n## [31,]    0    0    0    0    0    0    0\r\n## [32,]    0    0    0    0    0    0    0\r\n## [33,]    0    0    0    0    0    0    0\r\n## [34,]    0    0    0    0    0    0    0\r\n## [35,]    0    0    0    0    0    0    0\r\n## [36,]    0    0    0    0    0    0    0\r\n## [37,]    0    0    0    0    0    0    0\r\n## [38,]    0    0    0    0    0    0    0\r\n## [39,]    0    0    0    0    0    0    0\r\n## [40,]    0    0    0    0    0    0    0\r\n## [41,]    0    0    0    0    0    0    0\r\n## [42,]    0    0    0    0    0    0    0\r\n## [43,]    0    0    0    0    0    0    0\r\n## [44,]    0    0    0    0    0    0    0\r\n## [45,]    0    0    0    0    0    0    0\r\n## [46,]    0    0    0    0    0    0    0\r\n## [47,]    0    0    0    0    0    0    0\r\n## [48,]    0    0    0    0    0    0    0\r\n~~~\r\n\r\n#### `EQUIV`: 2 x 1 vector containing parameter sharing options.\r\nThese parameters allow the day of week and time of day effects to be shared by certain days or times.\r\n\r\n~~~ r\r\n## EQUIV[1]<-1 All days share total (per day) rate\r\n## EQUIV[1]<-2 Weekend/weekdays share total (per day) rate\r\n## EQUIV[1]<-3 Total (per day) rate unshared\r\n\r\n## EQUIV[2]<-1 All days share time profile\r\n## EQUIV[2]<-2 Weekend/weekdays share time profile\r\n## EQUIV[2]<-3 Time profile unshared\r\n~~~\r\n\r\n~~~ r\r\nEQUIV <- c(3, 3)\r\n~~~\r\n\r\n### Execution\r\nThe following code snippet reads the source code and estimates the MMPP model.  Note that the events matrix is not currently used in the code, but is a placeholder for future plotting features.\r\n\r\n~~~\r\nsource(\"/your_directory_here/MMPP.R\")\r\nsamples <- sensorMMPP(N, priors, c(50, 10, 1), events, c(3, 3))\r\n~~~\r\n\r\n### Output\r\nThe output is a list containing the following multi-dimensional arrays:\r\n\r\nName | Dimensions|Contents\r\n:---:| ---:|:---\r\n$$L$$ | $$D \\times T \\times N$$|The values of $$\\lambda$$ at each day - time slice for every iteration.\r\n$$Z$$ | $$D \\times T \\times N$$|The $$z=1$$ (event) or $$z=0$$ (no event) at each day - time slice for every iteration.  The average across all iterations gives us the probability of an event at specified day-time slice.\r\n$$M$$ | $$2 \\times 2 \\times N$$|The estimated transition probabilities for each iteration.\r\n$$N_0$$ | $$D \\times T \\times N$$|The estimated values of $$N_0(t)$$ for each iteration.\r\n$$N_E$$ | $$D \\times T \\times N$$|The estimated values of $$N_E(t)$$ for each iteration.\r\n$$logp_NgLM$$ | $$1 \\times N$$|The log-likelihood of $$P(N \\| L,M)$$ for each iteration.\r\n$$logp_NgLZ$$ | $$1 \\times N$$|The log-likelihood of $$P(N \\| L,Z)$$ for each iteration.\r\n\r\n\r\n~~~ r\r\nsummary(samples)\r\n\r\n##           Length Class  Mode   \r\n## L         168000 -none- numeric\r\n## Z         168000 -none- numeric\r\n## M            200 -none- numeric\r\n## N0        168000 -none- numeric\r\n## NE        168000 -none- numeric\r\n## logp_NgLM     50 -none- numeric\r\n## logp_NgLZ     50 -none- numeric\r\n## logpC          1 -none- numeric\r\n## logpGD         1 -none- numeric\r\n~~~\r\n\r\nThe following code averages the values of $$Z$$ across all iterations and flattens the matrix into three columns: observation, time of day, day, and probability of event.  The same code is applied to $$L$$ to obtain the average time profile of building entries/exits.\r\n\r\n~~~ r\r\nlibrary(reshape)\r\nZ_mean<-apply(samples$Z, c(1, 2), mean)\r\nZ_mean<-melt(Z_mean)\r\nL_mean<-apply(samples$L,c(1,2),mean)\r\nL_mean<-melt(L_mean)\r\n~~~\r\n\r\n![plot of chunk unnamed-chunk-2](assets/fig/unnamed-chunk-2.png)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}